<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deriv AITrader</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for a clean look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- ...existing code... -->
    <link rel="icon" type="image/x-icon" href="https://cdn.prod.website-files.com/65c76c6482e68a9e09d9b765/65c773033acbd57cd18cc4c8_deriv_favicon_32.png">
    <!-- ...existing code... -->    <style>
        /* Custom styles to complement Tailwind */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
            color: #d1d5db; /* text-gray-300 */
        }
        .card {
            background-color: #1f2937; /* bg-gray-800 */
            border: 1px solid #374151; /* border-gray-700 */
            border-radius: 0.75rem; /* rounded-xl */
            padding: 1.5rem; /* p-6 */
            box-shadow:
                0 0 12px 2px #00fff7, /* Neon cyan outer glow */
                0 0 32px 8px #1e40af44, /* Blue soft glow */
                0 4px 6px -1px rgb(0 0 0 / 0.1),
                0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: box-shadow 0.3s;
        }
        .card:hover {
            box-shadow:
                0 0 24px 6px #00fff7, /* Stronger glow on hover */
                0 0 48px 16px #1e40af88,
                0 4px 6px -1px rgb(0 0 0 / 0.1),
                0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        /* Optional: Glow for buttons */
        .card button, .card select, .card input {
            box-shadow: 0 0 8px 1px #00fff7aa;
            border: 1px solid #00fff733;
            transition: box-shadow 0.2s, border-color 0.2s;
        }
        .card button:focus, .card select:focus, .card input:focus {
            box-shadow: 0 0 16px 2px #00fff7cc;
            border-color: #00fff7;
        }
        .log-message {
            font-family: 'monospace';
            font-size: 0.8rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            margin-bottom: 0.25rem;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .log-error { background-color: #450a0a; color: #fecaca; }
        .log-success { background-color: #064e3b; color: #d1fae5; }
        .log-info { background-color: #1e3a8a; color: #dbeafe; }
        .log-api { background-color: #374151; color: #e5e7eb; }
        .log-update { background-color: #c6bb43; color: #3808f8; }

        /* Blinking animation for status */
        @keyframes blink {
            50% { opacity: 0.5; }
        }
        .blinking {
            animation: blink 1s linear infinite;
        }

        .trade-item {
            display: grid;
            /* Updated grid-template-columns: Type, Ref. ID, Buy time, Stake, Result, Total Profit/Loss */
            grid-template-columns: 0.8fr 1.2fr 1fr 0.8fr 0.7fr 1.2fr;
            gap: 8px;
            padding: 8px;
            border-bottom: 1px solid #374151;
            align-items: center;
        }
        .trade-item:last-child {
            border-bottom: none;
        }
        .trade-header {
            font-weight: bold;
            color: #9ca3af; /* gray-400 */
            text-align: left;
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-7xl mx-auto space-y-8">
        <!-- Header Section -->
        <header class="text-center mb-8">
            <div class="flex justify-center mb-4">
                <img src="https://cdn.prod.website-files.com/65c76c6482e68a9e09d9b765/65c773033acbd57cd18cc4c8_deriv_favicon_32.png" alt="Deriv Logo" class="w-14 h-14 rounded-full shadow-lg ring-4 ring-cyan-400/60 animate-pulse">
            </div>
            <h1 class="text-4xl md:text-5xl font-extrabold bg-gradient-to-r from-cyan-400 via-fuchsia-500 to-blue-500 bg-clip-text text-transparent drop-shadow-lg tracking-tight mb-2">
                Deriv Trader <span class="text-cyan-300 animate-pulse">AI</span> Auto Trader
            </h1>
            <p class="text-lg md:text-xl text-gray-300 mt-2 max-w-2xl mx-auto font-medium drop-shadow">
                <span class="text-cyan-400 font-semibold">Analyze</span> historical digit patterns and <span class="text-fuchsia-400 font-semibold">automate trades</span> with advanced AI-powered predictions.
            </p>
            <div class="flex justify-center mt-4 space-x-2">
                <span class="inline-block px-3 py-1 bg-cyan-900/60 text-cyan-300 rounded-full text-xs font-semibold shadow ring-1 ring-cyan-400/40">Futuristic</span>
                <span class="inline-block px-3 py-1 bg-fuchsia-900/60 text-fuchsia-300 rounded-full text-xs font-semibold shadow ring-1 ring-fuchsia-400/40">AI Powered</span>
                <span class="inline-block px-3 py-1 bg-blue-900/60 text-blue-300 rounded-full text-xs font-semibold shadow ring-1 ring-blue-400/40">Auto Trading</span>
            </div>
        </header>
        
        <!-- Login and Account Selection -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div class="card">
                <h2 class="text-xl font-semibold text-white mb-4">1. Login</h2>
                <div class="space-y-4">
                    <div class="relative">
                        <input type="password" id="api-token" placeholder="Enter your Deriv API Token" class="w-full bg-gray-900 border border-gray-700 text-white rounded-lg p-3 pr-10 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                        <button id="toggle-password" class="absolute inset-y-0 right-0 flex items-center px-3 text-gray-400 hover:text-white">
                            <svg id="eye-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
                                <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.022 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" />
                            </svg>
                            <svg id="eye-off-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 hidden" viewBox="0 0 20 20" fill="currentColor">
                               <path fill-rule="evenodd" d="M3.707 2.293a1 1 0 00-1.414 1.414l14 14a1 1 0 001.414-1.414l-1.473-1.473A10.014 10.014 0 0019.542 10C18.268 5.943 14.478 3 10 3a9.958 10 0 00-4.512 1.074L3.707 2.293zM10 12a2 2 0 100-4 2 2 0 000 4z" clip-rule="evenodd" />
                                <path d="M2 4.272l.943.943A10.072 10.072 0 00.458 10c1.274 4.057 5.022 7 9.542 7 .848 0 1.67-.11 2.454-.317l.734.734a1 1 0 101.414-1.414L3.414 2.858A1 1 0 002 4.272zM14 10a4 4 0 11-8 0 4 4 0 018 0z" />
                            </svg>
                        </button>
                    </div>
                     <input type="text" id="app-id" placeholder="Enter Deriv App ID (Optional)" class="w-full bg-gray-900 border border-gray-700 text-white rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                    <button id="connect-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">Connect</button>
                </div>
            </div>
            <div class="card">
                <h2 class="text-xl font-semibold text-white mb-4">2. Status & Account</h2>
                 <div id="status-indicator" class="flex items-center space-x-3 p-3 rounded-lg bg-gray-900 mb-4">
                    <div id="status-light" class="w-4 h-4 rounded-full bg-red-500"></div>
                    <span id="status-text" class="font-semibold text-white">Disconnected</span>
                </div>
                <div id="account-selection-card" class="hidden">
                    <label for="account-select" class="block text-sm font-medium text-gray-300 mb-1">Select Account</label>
                    <select id="account-select" class="w-full bg-gray-900 border border-gray-700 text-white rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none"></select>
                    <div id="account-balance" class="mt-3 text-lg font-bold text-green-400">Balance: ---</div>
                </div>
            </div>
        </div>

        <!-- Main Content Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            
            <!-- Left Column: Controls -->
            <div class="lg:col-span-1 space-y-6">
                <!-- Bot Configuration Card -->
                <div id="bot-controls-card" class="card hidden">
                    <h2 class="text-xl font-semibold text-white mb-4">3. Bot Configuration</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="total-historical-ticks" class="block text-sm font-medium text-gray-300 mb-1">Total Historical Ticks to Fetch</label>
                            <select id="total-historical-ticks" class="w-full bg-gray-900 border border-gray-700 text-white rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                                <option value="1000">Last 1,000</option>
                                <option value="500">Last 500</option>
                                <option value="2000">Last 2,000</option>
                                <option value="5000">Last 5,000</option>
                            </select>
                        </div>
                         <div>
                            <label for="synthetic-index" class="block text-sm font-medium text-gray-300 mb-1">Synthetic Index</label>
                            <select id="synthetic-index" class="w-full bg-gray-900 border border-gray-700 text-white rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                                <option value="R_10">Volatility 10 Index</option>
                                <option value="1HZ10V">1HZ 10 Index</option>
                                <option value="R_25">Volatility 25 Index</option>
                                <option value="1HZ25V">1HZ 25 Index</option>
                                <option value="R_50">Volatility 50 Index</option>
                                <option value="1HZ50V">1HZ 50 Index</option>
                                <option value="R_75">Volatility 75 Index</option>
                                <option value="1HZ75V">1HZ 75 Index</option>
                                <option value="R_100">Volatility 100 Index</option>
                                <option value="1HZ100V">1HZ 100 Index</option>
                            </select>
                        </div>
                        <div>
                            <label for="trade-type" class="block text-sm font-medium text-gray-300 mb-1">Trade Type</label>
                            <select id="trade-type" class="w-full bg-gray-900 border border-gray-700 text-white rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                                <option value="Bot">Bot (Auto Select)</option>
                                <option value="DIGITMATCH">Matches</option>
                                <option value="DIGITDIFF">Differs</option>
                                <option value="DIGITOVER">Over</option>
                                <option value="DIGITUNDER">Under</option>
                                <option value="DIGITODD">Even</option>
                                <option value="DIGITEVEN">Odd</option>
                            </select>
                        </div>
                        <div>
                            <label for="trade-tick-duration" class="block text-sm font-medium text-gray-300 mb-1">Trade Duration (Ticks)</label>
                            <select id="trade-tick-duration" class="w-full bg-gray-900 border border-gray-700 text-white rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                                <option value="1">1 Tick</option>
                                <option value="2">2 Ticks</option>
                                <option value="3">3 Ticks</option>
                                <option value="4">4 Ticks</option>
                                <option value="5">5 Ticks</option>
                            </select>
                        </div>

                        <div>
                            <label for="martingale-value" class="block text-sm font-medium text-gray-300 mb-1">Martingale Multiplier</label>
                            <select id="martingale-value" class="w-full bg-gray-900 border border-gray-700 text-white rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                                <option value="1">1x</option>
                                <option value="2">2x</option>
                                <option value="3">3x</option>
                                <option value="4">4x</option>
                                <option value="5">5x</option>
                            </select>
                        </div>
                        <div>
                            <label for="ap-threshold" class="block text-sm font-medium text-gray-300 mb-1">AP Threshold (0.0 - 1.0)</label>
                            <input type="number" id="ap-threshold" value="0.3" min="0" max="1" step="0.01" class="w-full bg-gray-900 border border-gray-700 text-white rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                            <p class="text-xs text-gray-400 mt-1">Minimum AP (Average Probability) required for bot to place a trade. Default: 0.3</p>
                        </div>

                        <div>
                             <label for="stake-amount" class="block text-sm font-medium text-gray-300 mb-1">Stake Amount (USD)</label>
                             <input type="number" id="stake-amount" value="0.35" step="0.01" class="w-full bg-gray-900 border border-gray-700 text-white rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                        </div>
                        <button id="fetch-data-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">Fetch & Analyze</button>
                        <div class="flex space-x-4">
                             <button id="start-bot-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed" disabled>Start Bot</button>
                             <button id="stop-bot-btn" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed" disabled>Stop Bot</button>
                        </div>
                    </div>
                </div>
                 <!-- Prediction Card -->
                <div id="prediction-card" class="card hidden">
                    <h2 class="text-xl font-semibold text-white mb-4">Prediction Model</h2>
                     <div class="bg-gray-900 p-4 rounded-lg">
                        <h3 class="text-lg font-semibold text-white">Predicted Next Digits/Parity Sequence</h3>
                        <p id="prediction-sequence" class="text-2xl font-bold text-emerald-400 tracking-widest mt-2">[ ? ? ? ]</p>
                        <p id="prediction-details" class="text-sm text-gray-400 mt-1">
                            Predicted Value: --, Confidence: --%, Type: --
                        </p>
                    </div>
                </div>
                 <!-- Financial Risk Disclaimer -->
                <div class="card bg-yellow-900/50 border-yellow-700">
                    <h3 class="font-bold text-yellow-300">Disclaimer: High Financial Risk</h3>
                    <p class="text-yellow-400 text-sm mt-2">Trading involves substantial risk and is not suitable for all investors. This tool is for educational and experimental purposes. Past performance is not indicative of future results. You are solely responsible for any financial losses.</p>
                </div>
            </div>

            <!-- Right Column: Data & Logs -->
            <div class="lg:col-span-2 space-y-6">
                <!-- Digit Analysis Card (1000 Ticks) -->
                <div class="card">
                    <h2 class="text-xl font-semibold text-white mb-4">Last Digit Analysis (All Fetched Ticks)</h2>
                    <p id="analysis-summary-1000" class="text-gray-400 text-sm mb-4">Fetch data to see distribution.</p>
                    <div id="digit-chart-1000" class="space-y-2"></div>
                </div>

                <!-- Digit Analysis Card (Custom) -->
                <div class="card">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-semibold text-white">Last Digit Analysis (Current View)</h2>
                        <select id="custom-tick-count" class="bg-gray-900 border border-gray-700 text-white rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                            <option value="10">10 Ticks</option>
                            <option value="20">20 Ticks</option>
                            <option value="50">50 Ticks</option>
                            <option value="100" selected>100 Ticks</option>
                            <option value="200">200 Ticks</option>
                            <option value="500">500 Ticks</option>
                        </select>
                    </div>
                    <p id="analysis-summary-custom" class="text-gray-400 text-sm mb-4">Fetch data to see distribution.</p>
                    <div id="digit-chart-custom" class="space-y-2"></div>
                </div>

                <!-- Previous Trades Card -->
                <div class="card">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-semibold text-white">Previous Trades</h2>
                        <select id="num-trades-to-show" class="bg-gray-900 border border-gray-700 text-white rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                            <option value="10" selected>Last 10</option>
                            <option value="50">Last 50</option>
                            <option value="100">Last 100</option>
                            <option value="all">All</option>
                        </select>
                    </div>
                    <div id="trade-history-container" class="w-full h-64 bg-gray-900 rounded-lg p-3 overflow-y-auto">
                        <div class="trade-item trade-header">
                            <div>Type</div>
                            <div>Ref. ID</div>
                            <div>Buy time</div>
                            <div>Stake</div>
                            <div>Result</div>
                            <div>Total profit/loss</div>
                        </div>
                        <div id="trades-list">
                            <!-- Trade items will be rendered here -->
                        </div>
                    </div>
                </div>

                <!-- Logs Card -->
                <div class="card">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-semibold text-white">Logs</h2>
                        <button id="clear-logs-btn" class="bg-gray-600 hover:bg-gray-700 text-white text-sm font-bold py-2 px-3 rounded-lg transition-colors">Clear Logs</button>
                    </div>
                    <div id="logs-container" class="w-full h-96 bg-gray-900 rounded-lg p-3 overflow-y-auto"></div>
                </div>

                <!-- Synthetic Chart Card -->
                <div class="card">
    <div class="flex flex-col md:flex-row md:items-center md:justify-between mb-4 gap-2">
        <div>
            <h2 class="text-xl font-semibold text-white">Synthetic Chart</h2>
            <div class="text-sm text-gray-400 mt-1">
                Selected: <span id="selected-synthetic-label" class="font-bold text-cyan-300"></span> | 
                Ticks: <span id="selected-tick-count-label" class="font-bold text-fuchsia-300"></span>
            </div>
        </div>
        <div class="flex items-center gap-2 mt-2 md:mt-0">
            <label for="chart-type-select" class="text-gray-300 text-sm mr-1">Chart Type:</label>
            <select id="chart-type-select" class="bg-gray-900 border border-gray-700 text-white rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                <option value="line">Line</option>
                <option value="candles">Candles (1m)</option>
            </select>
            <button id="refresh-synthetic-chart" class="ml-2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Refresh</button>
        </div>
    </div>
    <div id="synthetic-chart-container" class="w-full h-80 bg-gray-900 rounded-lg p-2 flex items-center justify-center">
        <span class="text-gray-500">Loading chart...</span>
    </div>
</div>
            </div>
        </div>
    </div>
    <!-- ...existing code... -->
    <!-- Add Chart.js before your main script -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- ...your existing <script> tag follows... -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial"></script>   
    <script>
        // --- DOM Elements ---
        const connectBtn = document.getElementById('connect-btn');
        const apiTokenInput = document.getElementById('api-token');
        const appIdInput = document.getElementById('app-id');
        const togglePasswordBtn = document.getElementById('toggle-password');
        const eyeIcon = document.getElementById('eye-icon');
        const eyeOffIcon = document.getElementById('eye-off-icon');

        const statusLight = document.getElementById('status-light');
        const statusText = document.getElementById('status-text');
        const accountSelectionCard = document.getElementById('account-selection-card');
        const accountSelect = document.getElementById('account-select');
        const botControlsCard = document.getElementById('bot-controls-card');
        const accountBalance = document.getElementById('account-balance');

        const totalHistoricalTicksSelect = document.getElementById('total-historical-ticks');
        const syntheticIndexSelect = document.getElementById('synthetic-index');
        const tradeTypeSelect = document.getElementById('trade-type');
        const stakeAmountInput = document.getElementById('stake-amount');
        const fetchDataBtn = document.getElementById('fetch-data-btn');
        const startBotBtn = document.getElementById('start-bot-btn');
        const stopBotBtn = document.getElementById('stop-bot-btn');

        const predictionCard = document.getElementById('prediction-card');
        const predictionSequence = document.getElementById('prediction-sequence');
        const predictionDetails = document.getElementById('prediction-details');
        
        const analysisSummary1000 = document.getElementById('analysis-summary-1000');
        const digitChart1000 = document.getElementById('digit-chart-1000');
        
        const customTickCountSelect = document.getElementById('custom-tick-count');
        const analysisSummaryCustom = document.getElementById('analysis-summary-custom');
        const digitChartCustom = document.getElementById('digit-chart-custom');

        const numTradesToShowSelect = document.getElementById('num-trades-to-show');
        const tradesList = document.getElementById('trades-list');

        const logsContainer = document.getElementById('logs-container');
        const clearLogsBtn = document.getElementById('clear-logs-btn');
        const tradeTickDurationSelect = document.getElementById('trade-tick-duration');
        const martingaleValueSelect = document.getElementById('martingale-value');


        // --- State Variables ---
        let websocket;
        let isAuthenticated = false;
        let isBotRunning = false;
        let tickHistory = [];
        let allTickHistory = []; // Stores all historical ticks as they come in + live ticks
        let tradeHistory = [];
        let lastContractId = null;
        let accounts = [];
        let pingInterval;
        let currentApiToken = '';
        let currentProposal = null;
        let isWaitingForTradeOutcome = false; // New flag to control trade cycle
        let isWaitingForTradeProposal = false; // New flag to control proposal request state

        let totalTicksToFetch = 1000;
        let fetchedTicksCount = 0;
        let lastFetchedTimestamp = null;
        let isFetchingHistoricalTicks = false;
        let historyFetchReqId = 0;
        let profitTableReqId = 0;

        let myClowestDigit = 0;
        let myChighestDigit = 0;
        let myAlowestDigit = 0
        let myAhighestDigit = 0;
        let lastPercentageCheck = 0;

        let percentageSummary = 'Occurrences: ';
        let minPercentage = Infinity;
        let maxPercentage = -1;
        let lowestDigit = -1;
        let highestDigit = -1;
        let LWD = -1;
        let HWD = -1;

        let pendingTradeCounter = 0; // Counter for pending trades
        let MAX_PENDING_TRADES = 5; // Maximum allowed pending trades before stopping the bot

        let lastDiffTradeTimestamp = 0; // Cooldown for DIGITDIFF trades

        const DEFAULT_DERIV_APP_ID = 65499;
        const PING_INTERVAL_MS = 20000;
        const MAX_TICKS_PER_API_CALL = 1000;
        const MAX_PROFIT_TABLE_LIMIT = 250; // This is a hard limit by Deriv API, not configurable by dropdown directly.
        const CONFIDENCE_THRESHOLD_EVEN_ODD = 51; // New threshold for Even/Odd
        const CONFIDENCE_THRESHOLD_OVER_UNDER = 62.5; // New threshold for Over/Under
        const DIFF_TRADE_COOLDOWN_MS = 15000; // 15 seconds cooldown for DIGITDIFF trades

        // --- WebSocket Logic ---
        // --- Begin: Differs Martingale Logic (GLOBAL SCOPE) ---
        let differsMartingaleActive = false;
        let differsMartingaleCount = 0;
        let differsMartingaleInitialStake = null;
        let differsMartingaleShouldTrigger = false;
        let differsMartingaleConsecWins = 0;
        let differsMartingaleWaiting = false;
        let LowPercentage = false;

        let martingaleNow = false;

        let prediction_output = {};
        let MA = 0;
        let LA = 0;
        let AP = 0;
        let formattedData = JSON.stringify({});
        let proposalRequest = null;
        let selectedTradeType = null; // This will be set based on the trade type selected by the user
        let foundTradeConditions = false;

        function connect() {
            const apiToken = apiTokenInput.value;
            const appId = appIdInput.value || DEFAULT_DERIV_APP_ID;
            if (!apiToken) {
                logMessage('Please enter an API Token.', 'error');
                return;
            }
        
            currentApiToken = apiToken;
        
            logMessage(`Connecting to Deriv with App ID: ${appId}...`, 'info');
            updateStatus('Connecting...', 'yellow', true);
            
            websocket = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${appId}`);
        
            websocket.onopen = () => {
                logMessage('WebSocket connection opened.', 'info');
                websocket.send(JSON.stringify({ authorize: currentApiToken }));
                startPinging();
            };
            websocket.onmessage = (event) => handleMessage(JSON.parse(event.data));
            websocket.onclose = () => {
                logMessage('WebSocket connection closed.', 'error');
                resetAppState("WebSocket closed unexpectedly");
                stopPinging();
                logMessage('Connection closed.', 'error');
            };
            websocket.onerror = (error) => {
                stopPinging();
                logMessage(`WebSocket Error: ${JSON.stringify(error)}`, 'error');
            };
        }

        function startPinging() {
            if (pingInterval) clearInterval(pingInterval);
            pingInterval = setInterval(() => {
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    websocket.send(JSON.stringify({ ping: 1 }));
                    logMessage('Sent WebSocket ping.', 'api');
                }
            }, PING_INTERVAL_MS);
            logMessage(`Started pinging every ${PING_INTERVAL_MS / 1000} seconds.`, 'info');
        }

        function stopPinging() {
            if (pingInterval) {
                clearInterval(pingInterval);
                pingInterval = null;
                logMessage('Stopped WebSocket pings.', 'info');
            }
        }

        function handleMessage(data) {

            if (data.error) {
                logMessage(`Error: ${data.error.message}`, 'error');
                if (data.error.code === 'AuthorizationFailed' || data.error.code === 'InvalidAppID') {
                    resetAppState("Authorization failed. Please check your API token and App ID.");
                }
                return;
            }
            
            switch (data.msg_type) {
                case 'authorize':
                    handleAuthorization(data.authorize);
                    break;
                
                case 'history':
                    if (data.echo_req.req_id === historyFetchReqId) {
                        const newPrices = data.history.prices.map(p => p.toString());
                        const newTimes = data.history.times;

                        allTickHistory.unshift(...newPrices);
                        fetchedTicksCount += newPrices.length;

                        if (newTimes && newTimes.length > 0) {
                            lastFetchedTimestamp = newTimes[0];
                        }

                        logMessage(`Fetched ${newPrices.length} ticks. Total fetched: ${fetchedTicksCount}/${totalTicksToFetch}.`, 'info');
                        
                        if (fetchedTicksCount < totalTicksToFetch && newPrices.length > 0) {
                            // logMessage(`Requesting next batch of historical ticks.`, 'info');
                            setTimeout(requestNextHistoryBatch, 500);
                        } else {
                            // logMessage(`--- END Historical Tick Data Fetch (Total: ${allTickHistory.length}) ---`, 'info');
                            isFetchingHistoricalTicks = false;
                            // fetchDataBtn.disabled = false;
                            updateStatus(`Logged in as ${accountSelect.value}`, 'green');
                            tickHistory = allTickHistory.slice(-totalTicksToFetch);
                            // logMessage('Historical data fetched. Running initial full analysis.', 'info');
                             if(!foundTradeConditions && !isWaitingForTradeProposal && !isWaitingForTradeOutcome){
                                runFullAnalysis(); // Run full analysis once historical data is fully fetched
                                runCustomAnalysis(); // Update the custom chart
                                checkPercentageForTrade(); // Check percentage for trade after full analysis
                             }
                             // checkPercentageForTrade(); // Check percentage for trade after full analysis
                            // if(checkPercentageForTrade()) {
                            //     logMessage('Trade conditions met. Sending Data to predictor.', 'success');
                            //     checkPercentageForTrade();
                            // } else {
                            //     logMessage('Trade conditions not met. Skipping data send to predictor.', 'warning');
                            // }
                            subscribeToTicks(syntheticIndexSelect.value);
                        }
                    }
                    break;
                    
                case 'tick':
                    if (allTickHistory.length > 0) {
                        // logMessage(`New tick received. Live value: ${data.tick.quote}. Updating analysis charts.`, 'info');
                        // // Always update tickHistory and run custom analysis for live chart updates
                        // allTickHistory.push(data.tick.quote.toString());
                        // if (allTickHistory.length > totalTicksToFetch) allTickHistory.shift(); 
                        // tickHistory = allTickHistory.slice(-totalTicksToFetch);
                        if(!foundTradeConditions && !isWaitingForTradeProposal && !isWaitingForTradeOutcome){
                            fetchData();
                            renderSyntheticChart();
                        }
                    }
                    break;
                
                case 'proposal':
                    if (data.proposal) {
                        currentProposal = data.proposal;
                        logMessage(`Received Proposal: ID ${currentProposal.id}, Ask Price: ${currentProposal.ask_price}`, 'success');
                        if (isBotRunning) {
                            sendBuyOrder(currentProposal.id, currentProposal.ask_price);
                        }
                    } else if (data.proposal_open) {
                        logMessage(`Proposal open (ID: ${data.proposal_open.id}), Current Price: ${data.proposal_open.current_price}`, 'api');
                    }
                    break;

                case 'buy':
                    if (data.buy) {
                        const contract = data.buy;
                        logMessage(`Trade placed. Contract ID: ${contract.contract_id}, Payout: ${contract.payout}`, 'success');
                        lastContractId = contract.contract_id;
                        isWaitingForTradeProposal = false
                        isWaitingForTradeOutcome = true; // Mark that we are waiting for the outcome of this trade
                    }
                    break;

                case 'transaction':
                     if (data.transaction && data.transaction.contract_id) {
                        // Check if this transaction is related to our last placed trade
                        if (data.transaction.contract_id === lastContractId) {
                            logMessage(`Transaction for our contract (${data.transaction.contract_id}) detected. Action: ${data.transaction.action}, Status: ${data.transaction.status}`, 'info');
                            logMessage(`Transaction Details: ${JSON.stringify(data.transaction)}`, 'api');
                            // Update account balance  
                            accountBalance.innerHTML = `Balance: <span class="text-blue-400">${data.transaction.balance.toFixed(2)}</span> ${data.transaction.currency}`;
                            // Only reset isWaitingForTradeOutcome if the contract is clearly concluded (sold or expired)
                            // The 'sell' or 'payout' action usually indicates conclusion.
                            // The 'InvalidContract' status on a buy also indicates immediate conclusion (failed buy)
                             //accountBalance.innerHTML = `Balance: <span class="text-blue-400">${data.balance.toFixed(2)}</span> ${data.currency}`;

                            if (data.transaction.action === 'sell' || data.transaction.action === 'payout' || data.transaction.status === 'InvalidContract') {
                                isWaitingForTradeOutcome = false; // Mark trade cycle as complete
                                logMessage(`Contract ${data.transaction.contract_id} concluded. Result will be updated from Profit Table.`, 'success');
                                if (isBotRunning) {
                                    logMessage('Trade cycle complete. Waiting for next tick to propose a new trade.', 'info');
                                }
                                fetchTradeHistoryFromAPI(); // Refresh profit table immediately
                            } else if (data.transaction.action === 'buy') {
                                // This is just a purchase, trade is now open.
                                logMessage(`Our contract (${data.transaction.contract_id}) was successfully purchased.`, 'info');
                            }
                        } else {
                            // Log other transactions not related to our active bot trade
                            logMessage(`Received non-bot transaction: ${JSON.stringify(data.transaction)}`, 'api');
                        }
                    }
                    break;
                
                case 'profit_table':
                    // logMessage(`Received profit table update: ${JSON.stringify(data.profit_table)}`, 'api');
                    if (data.echo_req.req_id === profitTableReqId) {
                        tradeHistory = data.profit_table.transactions.map(transaction => {
                            let predictedDisplay = '?';
                            if (transaction.shortcode.includes('DIGITMATCH') || transaction.shortcode.includes('DIGITDIFF') ||
                                transaction.shortcode.includes('DIGITOVER') || transaction.shortcode.includes('DIGITUNDER')) {
                                const barrierMatch = transaction.shortcode.match(/(?:DIGITMATCH|DIGITDIFF|DIGITOVER|DIGITUNDER):(\d)/);
                                if (barrierMatch && barrierMatch[1]) {
                                    predictedDisplay = barrierMatch[1];
                                }
                            } else if (transaction.shortcode.includes('DIGITODD')) {
                                predictedDisplay = 'Odd';
                            } else if (transaction.shortcode.includes('DIGITEVEN')) {
                                predictedDisplay = 'Even';
                            }

                            let finalProfit;
                            let tradeResult;

                            // Determine profit and result based on sell_price and buy_price
                            if (parseFloat(transaction.sell_price) === 0) {
                                // If sell_price is 0, it indicates a loss. Profit is negative of the stake.
                                tradeResult = 'Lost';
                                finalProfit = -parseFloat(transaction.buy_price);
                                
                            } else {
                                // If sell_price > 0, calculate profit/loss.
                                finalProfit = parseFloat(transaction.sell_price) - parseFloat(transaction.buy_price);
                                tradeResult = finalProfit >= 0 ? 'Won' : 'Lost'; // 'Won' if profit >= 0, 'Lost' if negative
                                }

                            return {
                                id: transaction.contract_id,
                                type: transaction.shortcode.match(/DIGIT(MATCH|DIFF|OVER|UNDER|ODD|EVEN)/)?.[0] || 'Unknown',
                                // predicted is not used in display but kept for data integrity in trade object
                                predicted: predictedDisplay, 
                                stake: parseFloat(transaction.buy_price),
                                profit: finalProfit,
                                result: tradeResult,
                                timestamp: new Date(transaction.purchase_time * 1000).toLocaleTimeString(),
                                purchase_time: transaction.purchase_time
                            };
                        });
                        logMessage(`Fetched ${tradeHistory.length} trades from Profit Table.`, 'info');
                        renderTradeHistory();
                        // --- Martingale logic for all trades ---
                        if (tradeHistory.length > 1) {
                            const lastTrade = tradeHistory[0];
                            const prevTrade = tradeHistory[1];

                            // If last trade is a loss, enable martingale
                            if (lastTrade.result === 'Lost' && prevTrade.result === 'Won') {
                                martingaleNow = true;
                                logMessage('Martingale triggered: Last trade was a loss. Next stake will be increased.', 'info');
                            }
                            else{
                                martingaleNow = false;
                                logMessage('Martingale not triggered: Last trade was a win or no previous trade.', 'info');
                            }

                            // // If previous trade was a loss and last trade is a win, reset martingale
                            // if (prevTrade.result === 'Won' && lastTrade.result === 'Won') {
                            //     martingaleNow = false;
                            //     logMessage('Martingale reset: Consecutive win after a loss. Stake returns to normal.', 'info');
                            // }
                        }
                    }
                    break;
            }
        }

        function handleAuthorization(authData) {
            isAuthenticated = true;
            accounts = authData.account_list;
            updateStatus(`Logged in as ${authData.loginid}`, 'green');
            logMessage(`Authorization successful. Welcome ${authData.email}.`, 'success');

            accountSelect.innerHTML = '';
            accounts.forEach(acc => {
                const option = document.createElement('option');
                option.value = acc.loginid;
                option.textContent = `${acc.loginid} (${acc.is_virtual ? 'Virtual' : 'Real'}, ${acc.currency})`;
                accountSelect.appendChild(option);
            });

            accountSelect.value = authData.loginid;
            accountBalance.innerHTML = `Balance: <span class="text-blue-400">${authData.balance.toFixed(2)}</span> ${authData.currency}`;
            
            accountSelectionCard.classList.remove('hidden');
            botControlsCard.classList.remove('hidden');
            predictionCard.classList.remove('hidden');
            apiTokenInput.disabled = true;
            appIdInput.disabled = true;
            connectBtn.textContent = 'Disconnect';
            connectBtn.classList.replace('bg-blue-600', 'bg-red-600');
            connectBtn.classList.replace('hover:bg-blue-700', 'hover:bg-red-700');

            // Initial fetch of trade history upon authorization
            logMessage('Initial fetch of trade history upon authorization.', 'info');
            
            fetchTradeHistoryFromAPI(); 
            fetchData();

            // Subscribe to all transactions immediately after authentication
            // and whenever connection status changes (implicitly via re-auth on re-connect)
            websocket.send(JSON.stringify({ transaction: 1, subscribe: 1 }));
            logMessage('Subscribed to transaction stream for continuous updates.', 'info');
        }

        function subscribeToTicks(symbol) {
            logMessage(`Subscribing to ticks for ${symbol}...`, 'info');
            websocket.send(JSON.stringify({ forget_all: 'ticks' }));
            websocket.send(JSON.stringify({ ticks: symbol, subscribe: 1 }));
        }
        
        function fetchData() {
            if (!isAuthenticated) {
                logMessage('Please connect first to fetch data.', 'error');
                return;
            }
            if (isFetchingHistoricalTicks) {
                logMessage('Already fetching historical ticks. Please wait.', 'info');
                return;
            }

            const symbol = syntheticIndexSelect.value;
            totalTicksToFetch = parseInt(totalHistoricalTicksSelect.value);

            logMessage(`Initiating historical data fetch for ${totalTicksToFetch} ticks on ${symbol}.`, 'info');
            updateStatus('Fetching data...', 'yellow', true);

            allTickHistory = [];
            fetchedTicksCount = 0;
            lastFetchedTimestamp = null;
            isFetchingHistoricalTicks = true;
            fetchDataBtn.disabled = true;
            startBotBtn.disabled = false;
            historyFetchReqId++;

            requestNextHistoryBatch();
        }

        function requestNextHistoryBatch() {
            const symbol = syntheticIndexSelect.value;
            const countForThisCall = Math.min(MAX_TICKS_PER_API_CALL, totalTicksToFetch - fetchedTicksCount);
            
            if (countForThisCall <= 0) {
                logMessage(`--- All requested historical ticks (${allTickHistory.length}) fetched. ---`, 'info');
                isFetchingHistoricalTicks = false;
                // fetchDataBtn.disabled = false;
                updateStatus(`Logged in as ${accountSelect.value}`, 'green');
                tickHistory = allTickHistory.slice(-totalTicksToFetch);
                logMessage('Historical data fully fetched. Running initial full analysis.', 'info');
                runFullAnalysis(); // Run full analysis once historical data is fully fetched
                runCustomAnalysis(); // Update the custom chart
                subscribeToTicks(syntheticIndexSelect.value);
                return;
            }

            const request = {
                ticks_history: symbol,
                end: lastFetchedTimestamp || "latest",
                count: countForThisCall,
                style: "ticks",
                req_id: historyFetchReqId
            };
            
            logMessage(`Fetching historical ticks batch (req_id: ${historyFetchReqId}, count: ${countForThisCall}, end: ${request.end}).`, 'api');
            websocket.send(JSON.stringify(request));
        }

        function fetchTradeHistoryFromAPI() {
            if (!isAuthenticated) {
                logMessage('Not authenticated. Cannot fetch trade history.', 'error');
                return;
            }
            profitTableReqId++;
            const selectedLimit = numTradesToShowSelect.value;
            let limit = MAX_PROFIT_TABLE_LIMIT; // Default to API max limit

            if (selectedLimit !== 'all') {
                limit = parseInt(selectedLimit);
            }
            
            logMessage(`Requesting Profit Table (limit: ${limit})...`, 'info');
            websocket.send(JSON.stringify({
                profit_table: 1,
                description: 1, // Include shortcode for parsing
                limit: limit,
                offset: 0,
                sort: 'DESC',
                req_id: profitTableReqId
            }));
        }


        // --- Helper functions for uniform decimal formatting ---
function getMaxObservedDecimals(prices) {
    let maxDecimals = 0;
    prices.forEach(price => {
        const parts = price.split('.');
        if (parts.length === 2) {
            maxDecimals = Math.max(maxDecimals, parts[1].length);
        }
    });
    return maxDecimals;
}

function formatPriceForExtraction(price, decimals) {
    if (typeof price !== 'string') price = price.toString();
    if (!price.includes('.')) {
        return price + '.' + '0'.repeat(decimals);
    }
    const [intPart, decPart] = price.split('.');
    return intPart + '.' + decPart.padEnd(decimals, '0');
}


// --- Analysis & Prediction Logic ---
        function runFullAnalysis() {
            //logMessage('Running full digit analysis and prediction model.', 'info');
            // Ensure tickHistory always reflects the selected totalHistoricalTicks
            let maxObservedDecimals = getMaxObservedDecimals(allTickHistory);
            // logMessage('=====================================================================', 'info');
            // logMessage('initial price list: ' + JSON.stringify(allTickHistory), 'info');
            // logMessage('=====================================================================', 'info');
            

            tickHistory = allTickHistory
                .slice(-parseInt(totalHistoricalTicksSelect.value))
                .map(price => formatPriceForExtraction(price, maxObservedDecimals));
                // logMessage('modified Price List: ' + JSON.stringify(tickHistory), 'info');
            if (tickHistory.length === 0) {
                predictionSequence.textContent = '[ ? ? ? ]';
                predictionDetails.innerHTML = 'Predicted Value: --, Confidence: --%, Type: --';
                logMessage('Not enough tick history for full analysis. Displaying placeholders.', 'info');
                return;
            }
            
            // Always update the 'All Fetched Ticks' chart
            let allFetchedLastDigits = tickHistory.map(price => price.slice(-1));

            // Convert last digits to integers before sending
            const integerDigits = allFetchedLastDigits.map(d => parseInt(d));
            formattedData = JSON.stringify({"data": integerDigits});
            


            myAlowestDigit, myAhighestDigit = analyzeAndDisplay(allFetchedLastDigits, digitChart1000, analysisSummary1000, `Analysis of the last ${allFetchedLastDigits.length} ticks.`, true);
            myAlowestDigit = LWD;
            myAhighestDigit = HWD;
            // logMessage(`Assigned LWD and HWD for the full analysis`, 'info');

            // Run prediction model based on the current tickHistory subset
            const analysisLastDigits = tickHistory.map(price => price.slice(-1));
            const predictionData = runPredictionModel(analysisLastDigits);
            
            selectedTradeType = tradeTypeSelect.value;

            predictionSequence.textContent = `[ ${predictionData.digitSequence.join(' ')} ]`; // Always show the 3-digit sequence
            logMessage(`Predicted digit sequence: [ ${predictionData.digitSequence.join(' ')} ]`, 'info');


              }
        
        function runCustomAnalysis() {
            // logMessage('Updating custom tick analysis chart.', 'info');
            if (tickHistory.length === 0) return;
            const count = parseInt(customTickCountSelect.value);
            const customTicks = tickHistory.slice(-count);
            const lastDigitsCustom = customTicks.map(price => price.slice(-1));
            
            myClowestDigit, myChighestDigit = analyzeAndDisplay(lastDigitsCustom, digitChartCustom, analysisSummaryCustom, `Analysis of the last ${customTicks.length} ticks.`, false);
            myClowestDigit = LWD;
            myChighestDigit = HWD;
        }

        function analyzeAndDisplay(digits, chartElement, summaryElement, summaryText, isAllTicksChart) {
            const digitCounts = {};
            for (let i = 0; i < 10; i++) digitCounts[i] = 0;
            digits.forEach(digit => digitCounts[digit]++);
            
            chartElement.innerHTML = '';
            summaryElement.textContent = summaryText;

            percentageSummary = 'Occurrences: ';
            minPercentage = Infinity;
            maxPercentage = -1;
            lowestDigit = -1;
            highestDigit = -1;

            if (digits.length > 0) {
                for (let i = 0; i < 10; i++) {
                    const count = digitCounts[i] || 0;
                    const percentage = (count / digits.length) * 100;
                    
                    if (percentage < minPercentage) {
                        minPercentage = percentage;
                        lowestDigit = i;
                    }
                    if (percentage > maxPercentage) {
                        maxPercentage = percentage;
                        highestDigit = i;
                    }
                }
            }
            LWD = -1;
            HWD = -1;

            for (let i = 0; i < 10; i++) {
                const count = digitCounts[i] || 0;
                const percentage = digits.length > 0 ? ((count / digits.length) * 100).toFixed(2) : 0;
                percentageSummary += `${i}: ${percentage}% `;

                let barColorClass = 'bg-cyan-500'; // Default color
                if (digits.length > 0) { // Only apply special colors if there's data
                    if (i === lowestDigit) {
                        LWD = i;
                        barColorClass = 'bg-red-500';
                    } else if (i === highestDigit) {
                        HWD = i;
                        barColorClass = 'bg-green-500';
                    }
                    if (i === lowestDigit || i === highestDigit) {
                        if(i <= 3) LowPercentage = true
                        else LowPercentage = false
                    }
                }
                
                // const barElement = document.createElement('div');
                // barElement.className = 'flex items-center space-x-3';
                // barElement.innerHTML = `
                //     <div class="w-8 font-bold text-lg text-white">${i}</div>
                //     <div class="flex-1 bg-gray-700 rounded-full h-6">
                //         <div class="${barColorClass} h-6 rounded-full text-xs font-medium text-blue-900 text-center p-1 leading-none" style="width: ${percentage > 0 ? percentage : 0}%">${percentage > 5 ? percentage+'%' : ''}</div>
                //     </div>
                //     <div class="w-16 text-right text-gray-400 text-sm">(${count})</div>
                // `;

                // Scale the bar width for better visualization
                const scaledPercentage = Math.min(percentage * 6, 100);

                const barElement = document.createElement('div');
                barElement.className = 'flex items-center space-x-3';
                barElement.innerHTML = `
                    <div class="w-8 font-bold text-lg text-white">${i}</div>
                    <div class="flex-1 bg-gray-700 rounded-full h-6">
                        <div class="${barColorClass} h-6 rounded-full text-xs font-medium text-blue-900 text-center p-1 leading-none" style="width: ${scaledPercentage}%">${percentage > 0 ? percentage+'%' : ''}</div>
                    </div>
                    <div class="w-16 text-right text-gray-400 text-sm">(${count})</div>
                `;
                chartElement.appendChild(barElement);
            }
            summaryElement.textContent += ` ${percentageSummary}`;
            // logMessage(`------------------`, 'info');
            logMessage(`LWD: ${LWD} --- HWD: ${HWD}`, 'info');
            // logMessage(`------------------`, 'info');
        }

        function runPredictionModel(digits) {
            if (digits.length === 0) {
                return {
                    digitSequence: ['?', '?', '?'],
                    evenOddPrediction: '?',
                    digitFrequencies: new Array(10).fill(0),
                    evenCount: 0,
                    oddCount: 0,
                    totalDigits: 0
                };
            }

            const transitions = {};
            for (let i = 0; i < 10; i++) {
                transitions[i] = {};
                for (let j = 0; j < 10; j++) {
                    transitions[i][j] = 0;
                }
            }

            const digitFrequencies = new Array(10).fill(0);
            let evenCount = 0;
            let oddCount = 0;
            const totalDigits = digits.length;

            digits.forEach(digitStr => {
                const digit = parseInt(digitStr);
                if (!isNaN(digit)) {
                    if (digit % 2 === 0) {
                        evenCount++;
                    } else {
                        oddCount++;
                    }
                    digitFrequencies[digit]++;
                }
            });

            for (let i = 0; i < digits.length; i++) {
                if (i < digits.length - 1) {
                    const currentDigit = parseInt(digits[i]);
                    const nextDigit = parseInt(digits[i+1]);
                    if (!isNaN(currentDigit) && !isNaN(nextDigit)) {
                        transitions[currentDigit][nextDigit]++;
                    }
                }
            }

            let lastKnownDigit = parseInt(digits[digits.length - 1]);
            if (isNaN(lastKnownDigit)) { 
                 lastKnownDigit = 0; 
            }

            const predictedDigitSequence = [];
            let currentPredictedDigit = lastKnownDigit;

            for (let i = 0; i < 3; i++) {
                const possibleNext = transitions[currentPredictedDigit];
                let mostLikelyNext = '?';
                
                let maxCount = -1;
                if (possibleNext && typeof possibleNext === 'object') {
                    for (const digitKey in possibleNext) {
                        const count = possibleNext[digitKey];
                        if (count > maxCount) {
                            maxCount = count;
                            mostLikelyNext = digitKey;
                        }
                    }
                }

                if ((maxCount <= 1 && digits.length > 0) || !possibleNext) {
                    let maxFreq = -1;
                    for (let digit = 0; digit < digitFrequencies.length; digit++) {
                        if (digitFrequencies[digit] > maxFreq) {
                            maxFreq = digitFrequencies[digit];
                            mostLikelyNext = digit.toString();
                        }
                    }
                }
                
                predictedDigitSequence.push(mostLikelyNext);
                currentPredictedDigit = parseInt(mostLikelyNext);
                if (isNaN(currentPredictedDigit)) {
                    currentPredictedDigit = 0; 
                }
            }

            const evenOddPrediction = evenCount > oddCount ? 'EVEN' : (oddCount > evenCount ? 'ODD' : '?');

            return {
                digitSequence: predictedDigitSequence,
                evenOddPrediction: evenOddPrediction,
                digitFrequencies: digitFrequencies,
                evenCount: evenCount,
                oddCount: oddCount,
                totalDigits: totalDigits
            };
        }
        
        // --- Trading Bot Logic ---
        function startBot() {
            if (!isAuthenticated || allTickHistory.length === 0) {
                logMessage('Cannot start bot: Not authenticated or no tick history.', 'error');
                return;
            }
            isBotRunning = true;
            isWaitingForTradeProposal = false;
            isWaitingForTradeOutcome = false; // Reset for a fresh start
            stopBotBtn.disabled = false;
            startBotBtn.disabled = true;
            fetchDataBtn.disabled = true;
            updateStatus('Bot Running', 'cyan', true);
            logMessage('Bot started. Requesting trade proposal...', 'success');
            fetchData();
            //requestTradeProposal(); // Initiate the first trade cycle
        }

        function stopBot() {
            isBotRunning = false;
            isWaitingForTradeOutcome = false; // Reset on stop
            isWaitingForTradeProposal = false; // Reset on stop
            stopBotBtn.disabled = true;
            startBotBtn.disabled = false;
            fetchDataBtn.disabled = false;
            updateStatus(`Logged in as ${accountSelect.value}`, 'green');
            logMessage('Bot stopped by user. Updating analysis UI.', 'info');
        }

        // Sends a proposal request to the Deriv API
        function requestTradeProposal(proposalRequest) {
            if (!isBotRunning) {
                logMessage('Bot is not running. Not requesting trade proposal.', 'info');
                return;
            }
            if (isWaitingForTradeOutcome) {
                logMessage('Bot is already waiting for a trade outcome. Skipping new proposal request.', 'info');
                return;
            }
            if (isWaitingForTradeProposal) {
                logMessage('Bot is already waiting for a trade proposal. Skipping new proposal request.', 'info');
                return;
            }
            if (!proposalRequest) {
                logMessage('No proposal request provided. Cannot proceed.', 'error');
                return;
            }
            else{
                logMessage(`Requesting trade proposal with params: ${JSON.stringify(proposalRequest)}`, 'api');
                // Send the proposal request to the WebSocket server
                websocket.send(JSON.stringify(proposalRequest));
                foundTradeConditions = false;
                isWaitingForTradeProposal = true;  
            }
        }

        function sendBuyOrder(proposalId, price) {
            const buyRequest = {
                buy: proposalId,
                price: price,
            };

            logMessage(`Sending BUY order for proposal ID: ${proposalId} at price: ${price}`, 'info');
            websocket.send(JSON.stringify(buyRequest));
        }

        function renderTradeHistory() {
            tradesList.innerHTML = '';

            let tradesToDisplay = tradeHistory;
            const numToShow = numTradesToShowSelect.value;

            if (numToShow !== 'all') {
                // Ensure we only slice if there's enough data
                tradesToDisplay = tradeHistory.slice(0, parseInt(numToShow));
            }

            if (tradesToDisplay.length === 0) {
                tradesList.innerHTML = '<div class="text-center text-gray-500 py-4">No trades yet.</div>';
                return;
            }

            tradesToDisplay.forEach(trade => {
                const tradeElement = document.createElement('div');
                tradeElement.className = 'trade-item';
                
                // Determine display for Result and Total Profit/Loss
                let resultText;
                let resultColor;
                let profitText;
                let profitColor;
                // logMessage(`Processing trade: ${JSON.stringify(trade)}`, 'info');

                if (trade.result === 'Won') {
                    resultText = 'Won';
                    resultColor = 'text-green-500';
                    profitText = `${trade.profit.toFixed(2)} USD`;
                    profitColor = 'text-green-500';
                    
                } else if (trade.result === 'Lost') {
                    resultText = 'Lost';
                    resultColor = 'text-red-500';
                    profitText = `${trade.profit.toFixed(2)} USD`; // Display negative stake value
                    profitColor = 'text-red-500';
                    
                } else { // Open trades
                    resultText = 'Open';
                    resultColor = 'text-yellow-500';
                    profitText = '---';
                    profitColor = 'text-gray-300';
                }

                tradeElement.innerHTML = `
                    <div class="text-xs text-blue-300">${trade.type.replace('DIGIT', '')}</div>
                    <div class="text-xs text-gray-400">${trade.id}</div>
                    <div class="text-xs text-gray-400">${trade.timestamp}</div>
                    <div class="text-sm text-gray-300">${trade.stake.toFixed(2)}</div>
                    <div class="text-sm font-bold ${resultColor}">${resultText}</div> <div class="text-sm font-bold ${profitColor}">${profitText}</div>
                `;
                tradesList.appendChild(tradeElement);
            });
        }

        function checkPercentageForTrade() {
            // logMessage(`Lowest Digit For All: ${myAlowestDigit}`, 'info');
            //     logMessage(`Highest Digit For All: ${myAhighestDigit}`, 'info');
            //     logMessage(`Lowest Digit For Custom List: ${myClowestDigit}`, 'info');
            //     logMessage(`Highest Digit For Custom List: ${myChighestDigit}`, 'info');
            //     logMessage(`time Now: ${Date.now()}`, 'info');
            //     logMessage(`Elapsed Time: ${Date.now() -   lastPercentageCheck}`, 'info');

                // Check if all lowest/highest digits are NOT below 3
                // if (Date.now() - lastPercentageCheck > 10000){
                    // logMessage('Resetting Index Percentage Timer.', 'info');
                    lastPercentageCheck = Date.now();
                    if(
                    typeof myAlowestDigit === "number" && typeof myAhighestDigit === "number" &&
                    typeof myClowestDigit === "number" && typeof myChighestDigit === "number"
                ) {
                    if(
                    myAlowestDigit <= 3 || myAhighestDigit <= 3 ||
                    myClowestDigit <= 3 || myChighestDigit <= 3
                ) {
                    
                    // Switch to the next volatility index in the dropdown
                    const currentIndex = syntheticIndexSelect.selectedIndex;
                    const totalOptions = syntheticIndexSelect.options.length;
                    const nextIndex = (currentIndex + 1) % totalOptions;
                    syntheticIndexSelect.selectedIndex = nextIndex;

                    // Update the label (if you want to show it somewhere else, update that element too)
                    logMessage(`All lowest/highest digits <= 3. Switching volatility index to: ${syntheticIndexSelect.options[nextIndex].text}`, 'update');

                    // Optionally, trigger a fetch for new data
                    // fetchData();
                    // return false; // Indicate that an index switch was made
                }

                else{
                    // logMessage('All lowest/highest digits are above 3. No index switch needed.', 'info');
                    getPredicitonNTrade();
                    // return true;
                }
            }
        }
        // }

        function getPredicitonNTrade(){

            // Send last digits to local server at http://localhost:5000
            // logMessage('=====>Sending last digits to local server for prediction...', 'info');
            fetch('http://127.0.0.1:5000/receive', {
            //fetch('https://3wzlrmz8-5000.uks1.devtunnels.ms/receive', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(formattedData)
            })
            .then(response => response.json())
            .then(data => {
                // logMessage('Successfully sent digits to local server.', 'success');
                // logMessage(`Server Response: ${JSON.stringify(data)}`, 'info');
                prediction_output = JSON.stringify(data);
                prediction_output = JSON.parse(prediction_output);
                MA = prediction_output.mostAppearing;
                LA = prediction_output.smallestNumberAppearing;
                AP = prediction_output.percentage;
                logMessage(`Prediction MA: ${MA} , Prediction LA: ${LA} , Prediction OP: ${AP}`, 'update');
                
            })
            .catch(error => {
                logMessage(`Error sending digits to local server: ${error}`, 'error');
            });

            if (selectedTradeType === 'Bot') {
                let detailsHtml = 'Highest Confidence Trades:<br>';
                let logDetails = 'Bot Decision Confidences:\n';

                // Use the prediction values from the local server (MA, LA, AP)
                detailsHtml += `OVER 3 (<span class="text-yellow-300">MA: ${MA}, LA: ${LA}, AP: ${(AP * 100).toFixed(2)}%</span>)<br>`;
                logDetails += `- OVER 3 (MA: ${MA}, LA: ${LA}, AP: ${(AP * 100).toFixed(2)}%)\n`;

                predictionDetails.innerHTML = detailsHtml;
                logMessage(logDetails, 'info');

                // Place trade if conditions are met
                // Get AP threshold from user input (default 0.3)
                const apThresholdInput = document.getElementById('ap-threshold');
                let apThreshold = 0.5;
                if (apThresholdInput && !isNaN(parseFloat(apThresholdInput.value))) {
                    apThreshold = parseFloat(apThresholdInput.value);
                    }
                if (MA >= 2 && LA >= 2 && AP > apThreshold && !LowPercentage && !isWaitingForTradeOutcome) {
                        logMessage(`Bot condition met: Placing OVER 3 trade (AP threshold: ${apThreshold}).`, 'success');
                        // Prepare contract params for OVER 3
                        const selectedTradeTypeForBot = 'DIGITOVER'; // Always use OVER for Bot trades
                        const predictedValue = 1;
                        const contractTypeSpecificParams = { barrier: 1};
                        let myStake = 0;
                        let martingaleValue = parseInt(martingaleValueSelect.value) || 1;
                    if(martingaleNow){
                        myStake = (martingaleValue * parseFloat(stakeAmountInput.value)).toFixed(2);
                        // logMessage(`Martingale active: Using ${martingaleValue}x stake of ${myStake} for this trade.`, 'info');
                    } else {
                        myStake = parseFloat(stakeAmountInput.value).toFixed(2);
                        // logMessage(`Using normal stake of ${myStake} for this trade.`, 'info');
                    }
                     proposalRequest = {
                        proposal: 1,
                        amount: parseFloat(myStake),
                        basis: "stake",
                        contract_type: selectedTradeTypeForBot,
                        currency: "USD",
                        duration: parseInt(tradeTickDurationSelect.value),
                        duration_unit: "t",
                        symbol: syntheticIndexSelect.value,
                        ...contractTypeSpecificParams,
                        subscribe: 1
                    };
                    // logMessage(`Requesting trade proposal with params: ${JSON.stringify(proposalRequest)}`, 'api');
                    foundTradeConditions = true;
                    requestTradeProposal(proposalRequest);
                    // isWaitingForTradeOutcome = true;
                    //websocket.send(JSON.stringify(proposalRequest));
                } 
                else {
                    // logMessage('Bot condition NOT met: No trade placed.', 'info');
                    predictionDetails.innerHTML += '<span class="text-yellow-300">No trade placed: Prediction confidence too low.</span>';
                }
   
            }
            else { // Manual trade type selection (not Bot)
                let displayPredictedValue = '--';
                let displayConfidence = 0; 
                let displayPreferredTradeType = selectedTradeType;

                const predictedDigit = parseInt(predictionData.digitSequence[0]);
                displayPredictedValue = isNaN(predictedDigit) ? '--' : predictedDigit;
                displayConfidence = (predictionData.digitFrequencies[predictedDigit] / predictionData.totalDigits * 100);
            
        }
  
        }


        // --- UI & Helper Functions ---
        function resetAppState(cause) {
            logMessage(`Resetting application state..., ${cause}`, 'error');
            isAuthenticated = false;
            isBotRunning = false;
            isWaitingForTradeOutcome = false; // Reset on app state reset
            isWaitingForTradeProposal = false; // Reset on app state reset
            foundTradeConditions = false;
            accounts = [];
            tickHistory = [];
            allTickHistory = [];
            tradeHistory = [];
            currentProposal = null;
            stopPinging();
            
            updateStatus('Disconnected', 'red');
            apiTokenInput.disabled = false;
            appIdInput.disabled = false;
            connectBtn.textContent = 'Connect';
            connectBtn.classList.replace('bg-blue-600', 'bg-red-600');
            connectBtn.classList.replace('hover:bg-blue-700', 'hover:bg-red-700');
            
            accountSelectionCard.classList.add('hidden');
            botControlsCard.classList.add('hidden');
            predictionCard.classList.add('hidden');
            startBotBtn.disabled = true;
            stopBotBtn.disabled = true;
            fetchDataBtn.disabled = false;
            accountBalance.textContent = 'Balance: ---';
            
            digitChart1000.innerHTML = '';
            analysisSummary1000.textContent = 'Fetch data to see distribution.';
            digitChartCustom.innerHTML = '';
            analysisSummaryCustom.textContent = 'Fetch data to see distribution.';
            predictionSequence.textContent = '[ ? ? ? ]';
            predictionDetails.innerHTML = 'Predicted Value: --, Confidence: --%, Type: --'; // Use innerHTML for potential spans
            renderTradeHistory();
            logMessage('Application state reset.', 'info');
        }

        function updateStatus(text, color, isBlinking = false) {
            statusText.textContent = text;
            statusLight.className = `w-4 h-4 rounded-full bg-${color}-500`;
            statusLight.classList.toggle('blinking', isBlinking);
        }

        function logMessage(message, type = 'info') {
            const logElement = document.createElement('div');
            logElement.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logElement.className = `log-message log-${type}`;
            logsContainer.appendChild(logElement);
            logsContainer.scrollTop = logsContainer.scrollHeight;
        }
        
        // --- Event Listeners ---
        connectBtn.addEventListener('click', () => {
            if (isAuthenticated) websocket.close();
            else connect();
        });
        
        togglePasswordBtn.addEventListener('click', () => {
            const isPassword = apiTokenInput.type === 'password';
            apiTokenInput.type = isPassword ? 'text' : 'password';
            eyeIcon.classList.toggle('hidden', isPassword);
            eyeOffIcon.classList.toggle('hidden', !isPassword);
        });

        accountSelect.addEventListener('change', () => {
            const selectedAccountLoginId = accountSelect.value;
            websocket.send(JSON.stringify({ authorize: currentApiToken, switch_account: selectedAccountLoginId }));
            logMessage(`Attempting to switch to account ${selectedAccountLoginId}. Waiting for authorization response to update balance.`, 'info');
        });
        
        syntheticIndexSelect.addEventListener('change', () => {
            if (isAuthenticated) {
                allTickHistory = [];
                tickHistory = [];
                logMessage(`Market changed to ${syntheticIndexSelect.value}. Please 'Fetch & Analyze' for new data.`, 'info');
                startBotBtn.disabled = true;
                subscribeToTicks(syntheticIndexSelect.value);
            }
        });

        totalHistoricalTicksSelect.addEventListener('change', fetchData);
        
        tradeTypeSelect.addEventListener('change', () => {
            if (isBotRunning) {
                logMessage('Cannot change trade type while bot is running. Please stop the bot first.', 'error');
                // Revert selection if bot is running
                const previousValue = tradeTypeSelect.dataset.previousValue || 'Bot';
                tradeTypeSelect.value = previousValue;
            } else {
                tradeTypeSelect.dataset.previousValue = tradeTypeSelect.value; // Store current value
            }
        });
        // Store initial value
        tradeTypeSelect.dataset.previousValue = tradeTypeSelect.value;

        fetchDataBtn.addEventListener('click', fetchData);
        customTickCountSelect.addEventListener('change', runCustomAnalysis);
        startBotBtn.addEventListener('click', startBot);
        stopBotBtn.addEventListener('click', stopBot);

        numTradesToShowSelect.addEventListener('change', fetchTradeHistoryFromAPI); // Call fetchTradeHistoryFromAPI on dropdown change

        clearLogsBtn.addEventListener('click', () => {
            logsContainer.innerHTML = '';
            logMessage('Logs cleared.', 'info');
        });

        // --- Synthetic Chart Logic ---
    const syntheticChartContainer = document.getElementById('synthetic-chart-container');
    const chartTypeSelect = document.getElementById('chart-type-select');
    const refreshSyntheticChartBtn = document.getElementById('refresh-synthetic-chart');
    const selectedSyntheticLabel = document.getElementById('selected-synthetic-label');
    const selectedTickCountLabel = document.getElementById('selected-tick-count-label');
    let syntheticChartInstance = null;

    function updateSyntheticLabels() {
        selectedSyntheticLabel.textContent = syntheticIndexSelect.options[syntheticIndexSelect.selectedIndex].text;
        selectedTickCountLabel.textContent = customTickCountSelect.value;
    }

    async function fetchSyntheticChartData(symbol, count, chartType) {
        // For candles, use ticks_history with style: "candles" and granularity: 60 (1 minute)
        // For line, use ticks_history with style: "ticks"
        const endpoint = 'https://api.deriv.com/api/v1/ticks_history';
        let params = {
            ticks_history: symbol,
            end: 'latest',
            count: count,
            style: chartType === 'candles' ? 'candles' : 'ticks',
        };
        if (chartType === 'candles') {
            params.granularity = 60; // 1 minute
        }
        // Deriv API requires POST via WebSocket, so we'll use the existing websocket if possible.
        // For demo, fallback to a mock or skip if not connected.
        return new Promise((resolve, reject) => {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                syntheticChartContainer.innerHTML = '<span class="text-red-400">Connect first to load chart.</span>';
                reject('WebSocket not connected');
                return;
            }
            const reqId = Math.floor(Math.random() * 1000000);
            const request = {
                ...params,
                req_id: reqId
            };
            function onChartData(event) {
                const data = JSON.parse(event.data);
                if (data.echo_req && data.echo_req.req_id === reqId) {
                    websocket.removeEventListener('message', onChartData);
                    if (data.error) {
                        reject(data.error.message);
                    } else {
                        resolve(data);
                   
                    }
                }
            }
            websocket.addEventListener('message', onChartData);
            websocket.send(JSON.stringify(request));
        });
    }

    async function renderSyntheticChart() {
        updateSyntheticLabels();
        syntheticChartContainer.innerHTML = '<span class="text-gray-500">Loading chart...</span>';
        const symbol = syntheticIndexSelect.value;
        const count = parseInt(customTickCountSelect.value);
        const chartType = chartTypeSelect.value;

        try {
            const data = await fetchSyntheticChartData(symbol, count, chartType);
            let chartData = {};
            let chartOptions = {};
            if (chartType === 'candles') {
                // Candle chart
                const candles = data.candles || [];
                if (!candles.length) throw new Error('No candle data');
                chartData = {
                    labels: candles.map(c => new Date(c.epoch * 1000).toLocaleTimeString()),
                    datasets: [{
                        label: 'Price',
                        data: candles.map(c => ({ o: c.open, h: c.high, l: c.low, c: c.close })),
                        borderColor: '#00fff7',
                        backgroundColor: 'rgba(0,255,247,0.1)',
                        type: 'candlestick'
                    }]
                };
                chartOptions = {
                    plugins: { legend: { display: false } },
                    scales: { x: { display: true }, y: { display: true } }
                };
            } else {
                // Line chart
                const prices = data.history.prices || [];
                const times = data.history.times || [];
                // console.log('Chart API response:', data); // Add this line
                // console.log('Prices:', prices, 'Times:', times); // Add this line
                if (!prices.length) throw new Error('No tick data');
                chartData = {
                    labels: times.map(t => new Date(t * 1000).toLocaleTimeString()),
                    datasets: [{
                        label: 'Price',
                        data: prices,
                        borderColor: '#00fff7',
                        backgroundColor: 'rgba(0,255,247,0.1)',
                        tension: 0.3,
                        pointRadius: 0
                    }]
                };
                chartOptions = {
                    plugins: { legend: { display: false } },
                    scales: { x: { display: true }, y: { display: true } }
                };
            }

            syntheticChartContainer.innerHTML = '<canvas id="syntheticChartCanvas"></canvas>';
            const ctx = document.getElementById('syntheticChartCanvas').getContext('2d');
            if (syntheticChartInstance) syntheticChartInstance.destroy();

            // For candlestick, you need chartjs-chart-financial plugin. If not available, fallback to line.
            if (chartType === 'candles' && window.Chart && Chart.registry.getPlugin('financial')) {
                syntheticChartInstance = new Chart(ctx, {
                    type: 'candlestick',
                    data: chartData,
                    options: chartOptions
                });
            } else {
                syntheticChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: chartData,
                    options: chartOptions
                });
            }
        } catch (err) {
            syntheticChartContainer.innerHTML = `<span class="text-red-400">Error loading chart: ${err}</span>`;
        }
    }

    // Update chart when controls change
    chartTypeSelect.addEventListener('change', renderSyntheticChart);
    customTickCountSelect.addEventListener('change', renderSyntheticChart);
    syntheticIndexSelect.addEventListener('change', renderSyntheticChart);
    refreshSyntheticChartBtn.addEventListener('click', renderSyntheticChart);

    // Initial chart render after connection
    if (typeof websocket !== 'undefined' && websocket && websocket.readyState === WebSocket.OPEN) {
        renderSyntheticChart();
    }
    </script>
<!-- ...existing code... -->